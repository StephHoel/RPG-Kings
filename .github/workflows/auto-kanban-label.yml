name: Auto Kanban (Label)

on:
  issues:
    types: [labeled]

jobs:
  label-sync:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Choose token
        id: token
        run: |
          if [ -n "${{ secrets.PROJECT_TOKEN }}" ]; then echo "TOKEN=${{ secrets.PROJECT_TOKEN }}" >> $GITHUB_OUTPUT; else echo "TOKEN=${{ secrets.GITHUB_TOKEN }}" >> $GITHUB_OUTPUT; fi

      - name: Login gh CLI
        run: echo "${{ steps.token.outputs.TOKEN }}" | gh auth login --with-token

      - name: Prevent event loop (check token owner)
        id: check
        env:
          TOKEN: ${{ steps.token.outputs.TOKEN }}
          EVENT_SENDER: ${{ github.event.sender.login }}
          REPO: ${{ github.repository }}
          ISSUE_NUM: ${{ github.event.issue.number }}
        run: |
          echo "${{ steps.token.outputs.TOKEN }}" | gh auth login --with-token
          # obter o login do proprietário do token (necessita gh autenticado)
          GH_USER=$(gh api user --jq .login 2>/dev/null || echo '')
          echo "Proprietário do token: $GH_USER"
          echo "Autor do evento: $EVENT_SENDER"
          # exportar o login do bot para comparação no passo de aplicação
          echo "bot=$GH_USER" >> $GITHUB_OUTPUT
          # detectar se existe um comentário marcador recente deixado pelo bot após uma sincronização
          IS_BOT_ACTION=false
          if [ "$GH_USER" = "$EVENT_SENDER" ]; then
            echo "O dono do token é o mesmo que o autor do evento; checando por marcador de ação do bot..."
            # buscar comentários do issue feitos pelo bot contendo 'auto-kanban: sync-id=' e pegar o mais recente
            LAST_MARKER=$(gh api repos/${REPO}/issues/${ISSUE_NUM}/comments --jq '.[] | select(.user.login=="'"$GH_USER"'" and (.body|test("auto-kanban: sync-id="))) | .created_at' 2>/dev/null | head -n1 || echo '')
            if [ -n "$LAST_MARKER" ]; then
              # converter para epoch e comparar com tempo atual (janela de 180 segundos)
              LAST_EPOCH=$(date -d "$LAST_MARKER" +%s)
              NOW_EPOCH=$(date -u +%s)
              DIFF=$(( NOW_EPOCH - LAST_EPOCH ))
              echo "Último marcador do bot: $LAST_MARKER (há $DIFF segundos)"
              if [ "$DIFF" -le 180 ]; then
                IS_BOT_ACTION=true
              fi
            fi
          fi
          echo "is_bot_action=$IS_BOT_ACTION" >> $GITHUB_OUTPUT

      - name: Map label to status
        env:
          REPO: ${{ github.repository }}
          ISSUE_NUM: ${{ github.event.issue.number }}
          LABEL: ${{ github.event.label.name }}
          TOKEN: ${{ steps.token.outputs.TOKEN }}
          COMMENT_ON_RESULT: 'true'
        run: |
          echo "GH_TOKEN=${{ steps.token.outputs.TOKEN }}" >> $GITHUB_ENV
          echo "GITHUB_TOKEN=${{ steps.token.outputs.TOKEN }}" >> $GITHUB_ENV
          # garantir que o gh use o mesmo token para que operações de label saiam do mesmo principal
          gh auth status
          
        
      - name: Map label to status (apply)
        if: ${{ github.event.sender.login != steps.check.outputs.bot || steps.check.outputs.is_bot_action != 'true' }}
        env:
          REPO: ${{ github.repository }}
          ISSUE_NUM: ${{ github.event.issue.number }}
          LABEL: ${{ github.event.label.name }}
          TOKEN: ${{ steps.token.outputs.TOKEN }}
          COMMENT_ON_RESULT: 'true'
          PROJECT_ID: PVT_kwHOAzdNtc4BIwXp
          STATUS_FIELD_ID: PVTSSF_lAHOAzdNtc4BIwXpzg5H3q8
          OPTION_BACKLOG: f75ad846
          OPTION_READY: 61e4505c
          OPTION_IN_PROGRESS: 47fc9ee4
          OPTION_IN_REVIEW: df73e18b
          OPTION_DONE: 98236657
        run: |
          echo "Issue #$ISSUE_NUM: rótulo acionado: $LABEL"
          # Verifica se a issue já tem o rótulo alvo; se sim, não altera labels (evita re-aplicar),
          # mas continua a sincronização do Project.
          CURRENT_LABELS=$(gh issue view $ISSUE_NUM --repo $REPO --json labels --jq '.labels[].name' 2>/dev/null || echo '')
          SKIP_LABEL_EDIT=false
          for L in $CURRENT_LABELS; do
            if [ "$L" = "$LABEL" ]; then
              echo "Rótulo alvo $LABEL já presente; não alterarei labels (apenas farei sync do Project)."
              SKIP_LABEL_EDIT=true
              break
            fi
          done
          case "$LABEL" in
            status/backlog)
              TARGET=status/backlog ;;
            status/ready)
              TARGET=status/ready ;;
            status/in-progress)
              TARGET=status/in-progress ;;
            status/in-review | status/review)
              TARGET=status/review ;;
            status/done)
              TARGET=status/done ;;
            *)
              echo "Rótulo não mapeado para status; pulando"; exit 0 ;;
          esac
          # Garantir que exista apenas um rótulo status/*: remover os existentes e adicionar o TARGET
          if [ "$SKIP_LABEL_EDIT" != 'true' ]; then
            EXISTING_LABELS_JSON=$(gh issue view $ISSUE_NUM --repo $REPO --json labels --jq '.labels[].name' 2>/dev/null)
            if [ -n "$EXISTING_LABELS_JSON" ]; then
              # remove any label starting with status/
              for L in $EXISTING_LABELS_JSON; do
                case "$L" in
                  status/*)
                    echo "(remover rótulo $L)" ;;
                  *) ;;
                esac
              done
            fi
            # add the new status label (comandos de edição de label foram removidos)
            echo "(adicionar rótulo $TARGET)"
            # marcador removido: não adicionar comentário automático de sincronização aqui
          else
            echo "Pulando alteração de labels porque o rótulo alvo já estava presente."
          fi
          # Try to sync ProjectV2 status (best-effort)
          # If we have an OPTION_* env that matches the target, pass its value (the option id).
          case "${TARGET#status/}" in
            backlog) STATUS_OPTION="$OPTION_BACKLOG" ;; 
            ready) STATUS_OPTION="$OPTION_READY" ;; 
            in-progress) STATUS_OPTION="$OPTION_IN_PROGRESS" ;; 
            in-review) STATUS_OPTION="$OPTION_IN_REVIEW" ;; 
            review) STATUS_OPTION="$OPTION_IN_REVIEW" ;; 
            done) STATUS_OPTION="$OPTION_DONE" ;; 
            *) echo "Rótulo não esperado" && exit 0 ;; 
          esac
          PROJECT_TOKEN=${{ secrets.PROJECT_TOKEN }} node ./scripts/sync-projectv2.mjs --owner ${{ github.repository_owner }} --repo ${{ github.event.repository.name }} --project-number 1 --issue $ISSUE_NUM --status "$STATUS_OPTION"
